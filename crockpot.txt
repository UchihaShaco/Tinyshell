
void	ts_init_data(t_data *data, char ***env, int first)
{
	if (first == YES)
	{
		data->flag_old = 1;
		data->prev_dir = NULL;
		data->cur_dir = getcwd(NULL, 0);
		data->num_prev_error = 0; // check header :P
		data->num_error = 0;
		data->num_tmp_var = 0; // just a tmp var might be useful
		data->tmp_var = NULL;
		ts_init_env(data, env);
		data->name_file = NO; // flag to check if it's a file (YES, NO)
	}
	data->num_prev_error = data->num_error;
	data->num_error = 0;
	data->empty_str = NO; // flag to check if the string is empty (YES, NO)
	data->home_dir = getenv("HOME");
	// data->build_in = YES; // flag to check if it's a build in command (YES, NO)
	data->num_cmd = 0;
	// data->fd_pipe[0] = 0; something you need 
	// data->fd_pipe[1] = 0; same as above
}

void	ts_found_dollar(t_data *data, char **str, int q_m, int *i_orig)
{
	int	i;

	i = (*i_orig);
	if (i == 0 && (*str)[i] == '~' && (*str)[i + 1] == '\0'
		&& q_m != 39 && q_m != 34)
	{
		ts_free_str(str);
		(*str) = ft_strdup(data->home_dir);
		i = ft_strlen(data->home_dir) - 1;
	}
	if ((*str)[i] == '$' && (*str)[i + 1] == '$')
		i += 2;
	else if ((*str)[i] == '$' && (*str)[i + 1] == '?')
		ts_put_num_error(data->num_prev_error, str, &i);
	else if ((*str)[i] == '$' && (*str)[i + 1] != ' '
		&& ((*str)[i + 1] != '\0' && q_m != 39))
	{
		ts_record_value(data, str, i);
		if ((*str)[0] == '\0')
			return ;
	}
	else
		i++;
	(*i_orig) = i;
}

// void print_t_cmd(t_cmd *cmd)
// {
//     // printf("\033[1;35m t_cmd: \n\033[0m");
//     // printf("  str: %s\n", cmd->str);
//     // printf("  num_arg: %d\n", cmd->num_arg);
//     // printf("  num_array_arg: %d\n", cmd->num_array_arg);
//     // // printf("  way_cmd: %s\n", cmd->way_cmd);
//     // printf("  count_redir: %d\n", cmd->count_redir);
//     // // printf("  bad_file: %d\n", cmd->bad_file);
//     // printf("  array_empty: %d\n", cmd->array_empty);
//     printf("\033[1;35m everything inside the   cmd->arg.str :\n\033[0m");
//     // for (int i = 0; i < cmd->num_arg; i++)
// 	// {
//     //     // printf("    arg[%d]:\n", i);
//     //     printf("      str: %s\n", cmd->arg[i].str);
//     //     // printf("      q_m: %d\n", cmd->arg[i].q_m);
//     //     printf("      space: %d\n", cmd->arg[i].space);
//     //     printf("      redir: %d\n", cmd->arg[i].redir);
//     //     printf("      empty_key: %d\n", cmd->arg[i].empty_key);
//     // }

//     printf(" \033[1;35m array_arg:\033[0m\n");
//     for (int i = 0; cmd->array_arg[i] != NULL; i++)
// 	{
//         printf("    array_arg[%d]: %s\n", i, cmd->array_arg[i]);
//     }
	    
//     printf("\033[1;35m  redir:\033[0m\n");
//     for (int i = 0; i < cmd->count_redir; i++) 
// 	{
//         printf("    redir[%d]: %d\n", i, cmd->redir[i]);
//     }

//     // printf("\033[1;35m  file:\033[0m\n");
//     for (int i = 0; i < cmd->count_redir; i++) 
// 	{
//         printf("    file[%d]: %s\n", i, cmd->file[i]);
//     }
// 	printf("\033[1;35m  redir:\033[0m\n");
//     // printf("\033[1;35m  fd: [%d, %d]\033[0m\n", cmd->fd[0], cmd->fd[1]);
//     // printf("  redir_born: [%d, %d]\n", cmd->redir_born[0], cmd->redir_born[1]);
//     // printf("  last_redir: %d\n", cmd->last_redir);
// }

void	ft_echo(char **arg, t_data *data)
// {
// 	int	i;
// 	int	nl;

// 	//check for -n flag. if there is, start the printing at index 2, else start at index 1
// 	if (arg[1] && ft_strncmp(arg[1], "-n", 3) == 0) 
// 	{
// 		i = 2;
// 		nl = 0;
// 	}
// 	else
// 	{
// 		i = 1;
// 		nl = 1;
// 	}
// 	//loop through args and print
// 	while (arg[i])
// 	{
// 		if (arg[i + 1] != NULL)
// 			print_string(2, data, arg[i], " ");
// 		else if (arg[i + 1] == NULL)
// 			print_string(1, data, arg[i]);
// 		i++;
// 	}
// 	//if no -n, also print /n after the last string is printed
// 	if (nl == 1)
// 		print_string(1, data, "\n");
// }

if (data->old_dir)
		free(data->old_dir);
	data->old_dir = data->cur_dir;
	data->cur_dir = getcwd(NULL, 0);
	pwd = find_var_envlist("PWD", data);
	if (pwd)
	{
		free(pwd->val);
		pwd->val = ft_strdup_lim(data->cur_dir, '\0', data);
		modify_our_env(pwd, data);
	}
	oldpwd = find_var_envlist("OLDPWD", data);
	if (oldpwd)
	{
		free(oldpwd->val);
		oldpwd->val = ft_strdup_lim(data->old_dir, '\0', data);
		modify_our_env(oldpwd, data);
	}

void	free_env_var(t_env *env_var)
{
	if (env_var->key)
		free(env_var->key);
	if (env_var->val)
		free(env_var->val);
	free(env_var);
}

void	remove_var(t_env *env_var, t_data *data)
{
	t_env *temp;

	temp = env_var;
	if (!env_var->prev)
		*data->env_list = env_var->next;
	else
		env_var->prev->next = env_var->next;
	if (env_var->next)
		env_var->next->prev = env_var->prev;
	free_env_var(temp);
}

 // void	ft_echo(char **arg, t_data *data)
// {
// 	int	i;
// 	int	nflag;

// 	i = 1;
// 	nflag = 0; 
// 	while (arg[i])
// 	{
// 		if (!detect_nflag(arg[i]))
// 			break;
// 		nflag++;
// 		i++;
// 	}
// 	while (arg[i])
// 	{
// 		if (arg[i + 1] != NULL)
// 		{
// 			ft_putstr_fd(arg[i], 1);
// 			ft_putstr_fd(" ", 1);
// 		}
// 		else if (arg[i + 1] == NULL)
// 			ft_putstr_fd(arg[i], 1);
// 		i++;
// 	}
// 	if (nflag == 0)
// 		ft_putstr_fd("\n", 1);
// 	exit(0);
// }

/* populates fd_array */
void	open_redir_files(int redir, int i, t_cmd *cmd, t_data *data)
{
	if (redir == 2)
	{
		cmd->fd_array[i] = open(cmd->file[i], O_RDONLY);
		if (cmd->fd_array[i] == -1)
		{
			put_strs_fd(3, data, 2, "bash: ", cmd->file[i], ": No such file or directory\n");
				
			//close fd_array, send null to pipe, and exit out of this child process to the next one
		}
	}
	else if (redir == 3)
	{
		cmd->fd_array[i] = open(cmd->file[i], O_CREAT | O_RDWR | O_TRUNC, 0666);
		if (cmd->fd_array[i] == -1)
			error(ERR_OPEN, data);
	}
	else if (redir == 4)
	{
		cmd->fd_array[i] = open(cmd->file[i], O_CREAT | O_RDWR | O_APPEND, 0666);
		if (cmd->fd_array[i] == -1)
			error(ERR_OPEN, data);
	}
	else if (redir == 5)
		cmd->fd_array[i] = -1;
}

/* write null to pipe */
void	pipe_null(int index, t_data *data)
{
	int	devnull;
	devnull = open("dev/null", O_WRONLY);
	if (devnull < 0)
		error(ERR_OPEN, data);
	ts_dup2(devnull, data->fd[index][1], data);
	close(devnull);
}